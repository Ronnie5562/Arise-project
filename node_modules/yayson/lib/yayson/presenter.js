module.exports = function(utils, adapter) {
  var Presenter;
  Presenter = (function() {
    var buildLinks;

    class Presenter {
      constructor(scope = {}) {
        this.scope = scope;
      }

      id(instance) {
        return this.constructor.adapter.id(instance);
      }

      selfLinks(instance) {}

      links() {}

      relationships() {}

      attributes(instance) {
        var attributes, key, relationships;
        if (instance == null) {
          return null;
        }
        attributes = utils.clone(this.constructor.adapter.get(instance));
        delete attributes['id'];
        relationships = this.relationships();
        for (key in relationships) {
          delete attributes[key];
        }
        return attributes;
      }

      includeRelationships(scope, instance) {
        var data, factory, key, presenter, relationships, results;
        relationships = this.relationships();
        results = [];
        for (key in relationships) {
          factory = relationships[key] || (function() {
            throw new Error(`Presenter for ${key} in ${this.type} is not defined`);
          }).call(this);
          presenter = new factory(scope);
          data = this.constructor.adapter.get(instance, key);
          if (data != null) {
            results.push(presenter.toJSON(data, {
              include: true
            }));
          } else {
            results.push(void 0);
          }
        }
        return results;
      }

      buildRelationships(instance) {
        var build, buildData, data, key, links, presenter, relationships, rels;
        if (instance == null) {
          return null;
        }
        rels = this.relationships();
        links = this.links(instance) || {};
        relationships = null;
        for (key in rels) {
          data = this.constructor.adapter.get(instance, key);
          presenter = rels[key];
          buildData = (d) => {
            return data = {
              id: this.constructor.adapter.id(d),
              type: presenter.prototype.type
            };
          };
          build = (d) => {
            var rel;
            rel = {};
            if (d != null) {
              rel.data = buildData(d);
            }
            if (links[key] != null) {
              rel.links = buildLinks(links[key]);
            } else if (d == null) {
              rel.data = null;
            }
            return rel;
          };
          relationships || (relationships = {});
          relationships[key] || (relationships[key] = {});
          if (data instanceof Array) {
            relationships[key].data = data.map(buildData);
            if (links[key] != null) {
              relationships[key].links = buildLinks(links[key]);
            }
          } else {
            relationships[key] = build(data);
          }
        }
        return relationships;
      }

      buildSelfLink(instance) {
        return buildLinks(this.selfLinks(instance));
      }

      toJSON(instanceOrCollection, options = {}) {
        var added, base, base1, base2, collection, instance, links, model, relationships;
        if (options.meta != null) {
          this.scope.meta = options.meta;
        }
        if (options.links != null) {
          this.scope.links = options.links;
        }
        (base = this.scope).data || (base.data = null);
        if (instanceOrCollection == null) {
          return this.scope;
        }
        if (instanceOrCollection instanceof Array) {
          collection = instanceOrCollection;
          (base1 = this.scope).data || (base1.data = []);
          collection.forEach((instance) => {
            return this.toJSON(instance, options);
          });
        } else {
          instance = instanceOrCollection;
          added = true;
          model = {
            id: this.id(instance),
            type: this.type,
            attributes: this.attributes(instance)
          };
          if (model.id === void 0) {
            delete model.id;
          }
          relationships = this.buildRelationships(instance);
          if (relationships != null) {
            model.relationships = relationships;
          }
          links = this.buildSelfLink(instance);
          if (links != null) {
            model.links = links;
          }
          if (options.include) {
            (base2 = this.scope).included || (base2.included = []);
            if (!utils.any(this.scope.included.concat(this.scope.data), function(i) {
              return i.id === model.id && i.type === model.type;
            })) {
              this.scope.included.push(model);
            } else {
              added = false;
            }
          } else if (this.scope.data != null) {
            if (!(this.scope.data instanceof Array && utils.any(this.scope.data, function(i) {
              return i.id === model.id;
            }))) {
              this.scope.data.push(model);
            } else {
              added = false;
            }
          } else {
            this.scope.data = model;
          }
          if (added) {
            this.includeRelationships(this.scope, instance);
          }
        }
        return this.scope;
      }

      render(instanceOrCollection, options) {
        if (utils.isPromise(instanceOrCollection)) {
          return instanceOrCollection.then((data) => {
            return this.toJSON(data, options);
          });
        } else {
          return this.toJSON(instanceOrCollection, options);
        }
      }

      static toJSON() {
        return (new this).toJSON(...arguments);
      }

      static render() {
        return (new this).render(...arguments);
      }

    };

    buildLinks = function(link) {
      if (link == null) {
        return;
      }
      if ((link.self != null) || (link.related != null)) {
        return link;
      } else {
        return {
          self: link
        };
      }
    };

    Presenter.adapter = adapter;

    Presenter.prototype.type = 'objects';

    return Presenter;

  }).call(this);
  return module.exports = Presenter;
};
