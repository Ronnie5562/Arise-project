module.exports = function(utils) {
  var Record, Store;
  Record = class Record {
    constructor(options) {
      ({id: this.id, type: this.type, attributes: this.attributes, relationships: this.relationships, links: this.links, meta: this.meta} = options);
    }

  };
  return Store = class Store {
    constructor(options) {
      this.reset();
    }

    reset() {
      this.records = [];
      return this.relations = {};
    }

    toModel(rec, type, models) {
      var base, currentModel, data, key, links, meta, model, name, ref, rel, resolve, typeAttribute;
      model = utils.clone(rec.attributes) || {};
      if (model.type) {
        typeAttribute = model.type;
      }
      model.id = rec.id;
      model.type = rec.type;
      models[type] || (models[type] = {});
      (base = models[type])[name = rec.id] || (base[name] = model);
      if (model.hasOwnProperty('meta')) {
        model.attributes = {
          meta: model.meta
        };
        delete model.meta;
      }
      if (rec.meta != null) {
        model.meta = rec.meta;
      }
      if (rec.links != null) {
        model.links = rec.links;
      }
      if (rec.relationships != null) {
        ref = rec.relationships;
        for (key in ref) {
          rel = ref[key];
          data = rel.data;
          links = rel.links;
          meta = rel.meta;
          model[key] = null;
          if (!((data != null) || (links != null))) {
            continue;
          }
          resolve = ({type, id}) => {
            return this.find(type, id, models);
          };
          model[key] = data instanceof Array ? data.map(resolve) : data != null ? resolve(data) : {};
          // Model of the relation
          currentModel = model[key];
          if (currentModel != null) {
            // retain the links and meta from the relationship entry
            // use as underscore property name because the currentModel may also have a link and meta reference
            currentModel._links = links || {};
            currentModel._meta = meta || {};
          }
        }
      }
      if (typeAttribute) {
        model.type = typeAttribute;
      }
      return model;
    }

    findRecord(type, id) {
      return utils.find(this.records, function(r) {
        return r.type === type && r.id === id;
      });
    }

    findRecords(type) {
      return utils.filter(this.records, function(r) {
        return r.type === type;
      });
    }

    find(type, id, models = {}) {
      var rec;
      rec = this.findRecord(type, id);
      if (rec == null) {
        return null;
      }
      models[type] || (models[type] = {});
      return models[type][id] || this.toModel(rec, type, models);
    }

    findAll(type, models = {}) {
      var recs;
      recs = this.findRecords(type);
      if (recs == null) {
        return [];
      }
      recs.forEach((rec) => {
        models[type] || (models[type] = {});
        return this.toModel(rec, type, models);
      });
      return utils.values(models[type]);
    }

    remove(type, id) {
      var records, remove;
      remove = (record) => {
        var index;
        index = this.records.indexOf(record);
        if (!(index < 0)) {
          return this.records.splice(index, 1);
        }
      };
      if (id != null) {
        return remove(this.findRecord(type, id));
      } else {
        records = this.findRecords(type);
        return records.map(remove);
      }
    }

    sync(body) {
      var models, recs, result, sync;
      sync = (data) => {
        var add;
        if (data == null) {
          return null;
        }
        add = (obj) => {
          var id, rec, type;
          ({type, id} = obj);
          this.remove(type, id);
          rec = new Record(obj);
          this.records.push(rec);
          return rec;
        };
        if (data instanceof Array) {
          return data.map(add);
        } else {
          return add(data);
        }
      };
      sync(body.included);
      recs = sync(body.data);
      if (recs == null) {
        return null;
      }
      models = {};
      result = null;
      if (recs instanceof Array) {
        result = recs.map((rec) => {
          return this.toModel(rec, rec.type, models);
        });
      } else {
        result = this.toModel(recs, recs.type, models);
      }
      if (body.hasOwnProperty('links')) {
        result.links = body.links;
      }
      if (body.hasOwnProperty('meta')) {
        result.meta = body.meta;
      }
      return result;
    }

  };
};
